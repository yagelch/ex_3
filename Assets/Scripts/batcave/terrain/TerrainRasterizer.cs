using UnityEngine;
using Infra;
using Infra.Collections;

namespace BatCave.Terrain {
/// <summary>
/// Rasterizing the terrain based on the points held by the game (those were
/// generated by the TerrainGenerator).
/// </summary>
public class TerrainRasterizer : MonoSingleton<TerrainRasterizer> {
    public float floorY = -2.2f;
    public float ceilingY = 2.2f;
    public GameObjectPool terrainPool;
	
	private Spline.ContinuousSpline topSpline;
    private Spline.ContinuousSpline bottomSpline;
	
    /// <summary>
    /// Creates the next terrain chunk (floor and ceiling).
    /// </summary>
    /// <param name="lastPointIndex">The index of the last point that was rasterized.</param>
    /// <returns>The index of the last point used in the rasterized chunk. If
    /// there are not enough points to rasterize the next chunk, returns the
    /// 'lastPointIndex' given.</returns>
    public static int RasterizeNextChunk(int lastPointIndex) {
        return instance._RasterizeNextChunk(lastPointIndex);
    }

    private int _RasterizeNextChunk(int lastPointIndex) {
        DebugUtils.Assert(lastPointIndex < Game.instance.terrainPoints.Count, "Last point index out of bounds");
        var startPoint = Game.instance.terrainPoints[lastPointIndex];
        if (lastPointIndex + 2 >= Game.instance.terrainPoints.Count) {
            DebugUtils.Log("Not enough points to rasterize");
            return lastPointIndex;
        }
        var endPoint = Game.instance.terrainPoints[lastPointIndex + 1];
        var nextPoint = Game.instance.terrainPoints[lastPointIndex + 2];
		
		
		
        // Create ceiling points.
        var ceilingPoints = GetPoints(true, startPoint, endPoint, nextPoint);
        var floorPoints = GetPoints(false, startPoint, endPoint, nextPoint);

        var chunk = terrainPool.Borrow<TerrainChunk>(ceilingPoints, floorPoints);
        DebugUtils.Log("Rasterized chunk " + chunk.name);
        return lastPointIndex + 1;
    }

    private Vector2[] GetPoints(bool isCeiling, params TerrainGenerator.TerrainPoint[] terrainPoints) {
        int index = 0;
        var startPoint = terrainPoints[index++];
        var endPoint = terrainPoints[index++];
        var nextPoint = terrainPoints[index++];

        float baseY = isCeiling ? ceilingY : floorY;

        // Create rasterized points.
        //var points = new Vector2[13]; 
		var points = new Vector2[60];
        index = 0;
        // Create flat edge at the base.
        points[index].x = endPoint.x;
        points[index++].y = baseY;
        points[index].x = startPoint.x;
        points[index++].y = baseY;
        // Go up to the start point.
        points[index].x = startPoint.x;
        points[index++].y = startPoint.GetY(isCeiling);

		Vector2[] addedPoints = new Vector2[1];
        addedPoints[0].x = nextPoint.x;
        addedPoints[0].y = nextPoint.GetY(isCeiling);
         
         
        if (startPoint.x == -3){
            Vector2[] tempTop = new Vector2[3];
            Vector2[] tempBottom = new Vector2[3];
            for (int i = 0; i < 3; i++) {
                tempTop[i].x = Game.instance.terrainPoints[i].x;
                tempTop[i].y = Game.instance.terrainPoints[i].ceilingY;
                tempBottom[i].x = Game.instance.terrainPoints[i].x;
                tempBottom[i].y = Game.instance.terrainPoints[i].floorY;
            }
            topSpline = new Spline.ContinuousSpline(tempTop);  
            bottomSpline = new Spline.ContinuousSpline(tempBottom);  
        }
        else{
    		if (isCeiling == true)
    		{			
                topSpline.AddControlPoints(addedPoints);
            }
    		else {
                bottomSpline.AddControlPoints(addedPoints);
    		}
        }
		
        float delta = (endPoint.x - startPoint.x)/ (points.Length-3) ;
		while(index < points.Length - 1) {
            float interpolated = points[index - 1].x + delta;
            points[index].x = interpolated;
            if (isCeiling) {points[index].y = topSpline.Value(interpolated);}
            else {points[index].y = bottomSpline.Value(interpolated);}
            index++;
        }
			
        // Finish with the end point.
        points[index].x = endPoint.x;
        points[index++].y = endPoint.GetY(isCeiling);
        return points;
    }
}
}
